// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tenc-bidding.proto

#ifndef PROTOBUF_tenc_2dbidding_2eproto__INCLUDED
#define PROTOBUF_tenc_2dbidding_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace TENC {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_tenc_2dbidding_2eproto();
void protobuf_AssignDesc_tenc_2dbidding_2eproto();
void protobuf_ShutdownFile_tenc_2dbidding_2eproto();

class Request;
class Request_Impression;
class Request_Impression_Banner;
class Request_Impression_Video;
class Request_Site;
class Request_Device;
class Request_User;
class Response;
class Response_Bid;
class Response_SeatBid;

// ===================================================================

class Request_Impression_Banner : public ::google::protobuf::Message {
 public:
  Request_Impression_Banner();
  virtual ~Request_Impression_Banner();

  Request_Impression_Banner(const Request_Impression_Banner& from);

  inline Request_Impression_Banner& operator=(const Request_Impression_Banner& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_Impression_Banner& default_instance();

  void Swap(Request_Impression_Banner* other);

  // implements Message ----------------------------------------------

  Request_Impression_Banner* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_Impression_Banner& from);
  void MergeFrom(const Request_Impression_Banner& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 width = 1;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 1;
  inline ::google::protobuf::uint32 width() const;
  inline void set_width(::google::protobuf::uint32 value);

  // optional uint32 height = 2;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 2;
  inline ::google::protobuf::uint32 height() const;
  inline void set_height(::google::protobuf::uint32 value);

  // repeated string mimes = 3;
  inline int mimes_size() const;
  inline void clear_mimes();
  static const int kMimesFieldNumber = 3;
  inline const ::std::string& mimes(int index) const;
  inline ::std::string* mutable_mimes(int index);
  inline void set_mimes(int index, const ::std::string& value);
  inline void set_mimes(int index, const char* value);
  inline void set_mimes(int index, const char* value, size_t size);
  inline ::std::string* add_mimes();
  inline void add_mimes(const ::std::string& value);
  inline void add_mimes(const char* value);
  inline void add_mimes(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& mimes() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_mimes();

  // optional string extra_style = 4;
  inline bool has_extra_style() const;
  inline void clear_extra_style();
  static const int kExtraStyleFieldNumber = 4;
  inline const ::std::string& extra_style() const;
  inline void set_extra_style(const ::std::string& value);
  inline void set_extra_style(const char* value);
  inline void set_extra_style(const char* value, size_t size);
  inline ::std::string* mutable_extra_style();
  inline ::std::string* release_extra_style();
  inline void set_allocated_extra_style(::std::string* extra_style);

  // optional uint32 visibility = 5;
  inline bool has_visibility() const;
  inline void clear_visibility();
  static const int kVisibilityFieldNumber = 5;
  inline ::google::protobuf::uint32 visibility() const;
  inline void set_visibility(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TENC.Request.Impression.Banner)
 private:
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_extra_style();
  inline void clear_has_extra_style();
  inline void set_has_visibility();
  inline void clear_has_visibility();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;
  ::google::protobuf::RepeatedPtrField< ::std::string> mimes_;
  ::std::string* extra_style_;
  ::google::protobuf::uint32 visibility_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_tenc_2dbidding_2eproto();
  friend void protobuf_AssignDesc_tenc_2dbidding_2eproto();
  friend void protobuf_ShutdownFile_tenc_2dbidding_2eproto();

  void InitAsDefaultInstance();
  static Request_Impression_Banner* default_instance_;
};
// -------------------------------------------------------------------

class Request_Impression_Video : public ::google::protobuf::Message {
 public:
  Request_Impression_Video();
  virtual ~Request_Impression_Video();

  Request_Impression_Video(const Request_Impression_Video& from);

  inline Request_Impression_Video& operator=(const Request_Impression_Video& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_Impression_Video& default_instance();

  void Swap(Request_Impression_Video* other);

  // implements Message ----------------------------------------------

  Request_Impression_Video* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_Impression_Video& from);
  void MergeFrom(const Request_Impression_Video& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string mimes = 1;
  inline int mimes_size() const;
  inline void clear_mimes();
  static const int kMimesFieldNumber = 1;
  inline const ::std::string& mimes(int index) const;
  inline ::std::string* mutable_mimes(int index);
  inline void set_mimes(int index, const ::std::string& value);
  inline void set_mimes(int index, const char* value);
  inline void set_mimes(int index, const char* value, size_t size);
  inline ::std::string* add_mimes();
  inline void add_mimes(const ::std::string& value);
  inline void add_mimes(const char* value);
  inline void add_mimes(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& mimes() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_mimes();

  // optional uint32 linearity = 2;
  inline bool has_linearity() const;
  inline void clear_linearity();
  static const int kLinearityFieldNumber = 2;
  inline ::google::protobuf::uint32 linearity() const;
  inline void set_linearity(::google::protobuf::uint32 value);

  // optional uint32 minduration = 3;
  inline bool has_minduration() const;
  inline void clear_minduration();
  static const int kMindurationFieldNumber = 3;
  inline ::google::protobuf::uint32 minduration() const;
  inline void set_minduration(::google::protobuf::uint32 value);

  // optional uint32 maxduration = 4;
  inline bool has_maxduration() const;
  inline void clear_maxduration();
  static const int kMaxdurationFieldNumber = 4;
  inline ::google::protobuf::uint32 maxduration() const;
  inline void set_maxduration(::google::protobuf::uint32 value);

  // optional uint32 protocol = 5;
  inline bool has_protocol() const;
  inline void clear_protocol();
  static const int kProtocolFieldNumber = 5;
  inline ::google::protobuf::uint32 protocol() const;
  inline void set_protocol(::google::protobuf::uint32 value);

  // optional uint32 width = 6;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 6;
  inline ::google::protobuf::uint32 width() const;
  inline void set_width(::google::protobuf::uint32 value);

  // optional uint32 height = 7;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 7;
  inline ::google::protobuf::uint32 height() const;
  inline void set_height(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TENC.Request.Impression.Video)
 private:
  inline void set_has_linearity();
  inline void clear_has_linearity();
  inline void set_has_minduration();
  inline void clear_has_minduration();
  inline void set_has_maxduration();
  inline void clear_has_maxduration();
  inline void set_has_protocol();
  inline void clear_has_protocol();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> mimes_;
  ::google::protobuf::uint32 linearity_;
  ::google::protobuf::uint32 minduration_;
  ::google::protobuf::uint32 maxduration_;
  ::google::protobuf::uint32 protocol_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_tenc_2dbidding_2eproto();
  friend void protobuf_AssignDesc_tenc_2dbidding_2eproto();
  friend void protobuf_ShutdownFile_tenc_2dbidding_2eproto();

  void InitAsDefaultInstance();
  static Request_Impression_Video* default_instance_;
};
// -------------------------------------------------------------------

class Request_Impression : public ::google::protobuf::Message {
 public:
  Request_Impression();
  virtual ~Request_Impression();

  Request_Impression(const Request_Impression& from);

  inline Request_Impression& operator=(const Request_Impression& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_Impression& default_instance();

  void Swap(Request_Impression* other);

  // implements Message ----------------------------------------------

  Request_Impression* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_Impression& from);
  void MergeFrom(const Request_Impression& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Request_Impression_Banner Banner;
  typedef Request_Impression_Video Video;

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string tagid = 2;
  inline bool has_tagid() const;
  inline void clear_tagid();
  static const int kTagidFieldNumber = 2;
  inline const ::std::string& tagid() const;
  inline void set_tagid(const ::std::string& value);
  inline void set_tagid(const char* value);
  inline void set_tagid(const char* value, size_t size);
  inline ::std::string* mutable_tagid();
  inline ::std::string* release_tagid();
  inline void set_allocated_tagid(::std::string* tagid);

  // optional float bidfloor = 3;
  inline bool has_bidfloor() const;
  inline void clear_bidfloor();
  static const int kBidfloorFieldNumber = 3;
  inline float bidfloor() const;
  inline void set_bidfloor(float value);

  // optional .TENC.Request.Impression.Banner banner = 4;
  inline bool has_banner() const;
  inline void clear_banner();
  static const int kBannerFieldNumber = 4;
  inline const ::TENC::Request_Impression_Banner& banner() const;
  inline ::TENC::Request_Impression_Banner* mutable_banner();
  inline ::TENC::Request_Impression_Banner* release_banner();
  inline void set_allocated_banner(::TENC::Request_Impression_Banner* banner);

  // optional .TENC.Request.Impression.Video video = 5;
  inline bool has_video() const;
  inline void clear_video();
  static const int kVideoFieldNumber = 5;
  inline const ::TENC::Request_Impression_Video& video() const;
  inline ::TENC::Request_Impression_Video* mutable_video();
  inline ::TENC::Request_Impression_Video* release_video();
  inline void set_allocated_video(::TENC::Request_Impression_Video* video);

  // optional string clientid = 6;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientidFieldNumber = 6;
  inline const ::std::string& clientid() const;
  inline void set_clientid(const ::std::string& value);
  inline void set_clientid(const char* value);
  inline void set_clientid(const char* value, size_t size);
  inline ::std::string* mutable_clientid();
  inline ::std::string* release_clientid();
  inline void set_allocated_clientid(::std::string* clientid);

  // optional string tradecode = 7;
  inline bool has_tradecode() const;
  inline void clear_tradecode();
  static const int kTradecodeFieldNumber = 7;
  inline const ::std::string& tradecode() const;
  inline void set_tradecode(const ::std::string& value);
  inline void set_tradecode(const char* value);
  inline void set_tradecode(const char* value, size_t size);
  inline ::std::string* mutable_tradecode();
  inline ::std::string* release_tradecode();
  inline void set_allocated_tradecode(::std::string* tradecode);

  // optional string sns_lists = 8;
  inline bool has_sns_lists() const;
  inline void clear_sns_lists();
  static const int kSnsListsFieldNumber = 8;
  inline const ::std::string& sns_lists() const;
  inline void set_sns_lists(const ::std::string& value);
  inline void set_sns_lists(const char* value);
  inline void set_sns_lists(const char* value, size_t size);
  inline ::std::string* mutable_sns_lists();
  inline ::std::string* release_sns_lists();
  inline void set_allocated_sns_lists(::std::string* sns_lists);

  // @@protoc_insertion_point(class_scope:TENC.Request.Impression)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_tagid();
  inline void clear_has_tagid();
  inline void set_has_bidfloor();
  inline void clear_has_bidfloor();
  inline void set_has_banner();
  inline void clear_has_banner();
  inline void set_has_video();
  inline void clear_has_video();
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_tradecode();
  inline void clear_has_tradecode();
  inline void set_has_sns_lists();
  inline void clear_has_sns_lists();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* tagid_;
  ::TENC::Request_Impression_Banner* banner_;
  ::TENC::Request_Impression_Video* video_;
  ::std::string* clientid_;
  ::std::string* tradecode_;
  ::std::string* sns_lists_;
  float bidfloor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_tenc_2dbidding_2eproto();
  friend void protobuf_AssignDesc_tenc_2dbidding_2eproto();
  friend void protobuf_ShutdownFile_tenc_2dbidding_2eproto();

  void InitAsDefaultInstance();
  static Request_Impression* default_instance_;
};
// -------------------------------------------------------------------

class Request_Site : public ::google::protobuf::Message {
 public:
  Request_Site();
  virtual ~Request_Site();

  Request_Site(const Request_Site& from);

  inline Request_Site& operator=(const Request_Site& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_Site& default_instance();

  void Swap(Request_Site* other);

  // implements Message ----------------------------------------------

  Request_Site* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_Site& from);
  void MergeFrom(const Request_Site& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string page = 2;
  inline bool has_page() const;
  inline void clear_page();
  static const int kPageFieldNumber = 2;
  inline const ::std::string& page() const;
  inline void set_page(const ::std::string& value);
  inline void set_page(const char* value);
  inline void set_page(const char* value, size_t size);
  inline ::std::string* mutable_page();
  inline ::std::string* release_page();
  inline void set_allocated_page(::std::string* page);

  // optional string ref = 3;
  inline bool has_ref() const;
  inline void clear_ref();
  static const int kRefFieldNumber = 3;
  inline const ::std::string& ref() const;
  inline void set_ref(const ::std::string& value);
  inline void set_ref(const char* value);
  inline void set_ref(const char* value, size_t size);
  inline ::std::string* mutable_ref();
  inline ::std::string* release_ref();
  inline void set_allocated_ref(::std::string* ref);

  // @@protoc_insertion_point(class_scope:TENC.Request.Site)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_page();
  inline void clear_has_page();
  inline void set_has_ref();
  inline void clear_has_ref();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* page_;
  ::std::string* ref_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_tenc_2dbidding_2eproto();
  friend void protobuf_AssignDesc_tenc_2dbidding_2eproto();
  friend void protobuf_ShutdownFile_tenc_2dbidding_2eproto();

  void InitAsDefaultInstance();
  static Request_Site* default_instance_;
};
// -------------------------------------------------------------------

class Request_Device : public ::google::protobuf::Message {
 public:
  Request_Device();
  virtual ~Request_Device();

  Request_Device(const Request_Device& from);

  inline Request_Device& operator=(const Request_Device& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_Device& default_instance();

  void Swap(Request_Device* other);

  // implements Message ----------------------------------------------

  Request_Device* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_Device& from);
  void MergeFrom(const Request_Device& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional string ua = 2;
  inline bool has_ua() const;
  inline void clear_ua();
  static const int kUaFieldNumber = 2;
  inline const ::std::string& ua() const;
  inline void set_ua(const ::std::string& value);
  inline void set_ua(const char* value);
  inline void set_ua(const char* value, size_t size);
  inline ::std::string* mutable_ua();
  inline ::std::string* release_ua();
  inline void set_allocated_ua(::std::string* ua);

  // @@protoc_insertion_point(class_scope:TENC.Request.Device)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_ua();
  inline void clear_has_ua();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ip_;
  ::std::string* ua_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_tenc_2dbidding_2eproto();
  friend void protobuf_AssignDesc_tenc_2dbidding_2eproto();
  friend void protobuf_ShutdownFile_tenc_2dbidding_2eproto();

  void InitAsDefaultInstance();
  static Request_Device* default_instance_;
};
// -------------------------------------------------------------------

class Request_User : public ::google::protobuf::Message {
 public:
  Request_User();
  virtual ~Request_User();

  Request_User(const Request_User& from);

  inline Request_User& operator=(const Request_User& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_User& default_instance();

  void Swap(Request_User* other);

  // implements Message ----------------------------------------------

  Request_User* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_User& from);
  void MergeFrom(const Request_User& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string buyerid = 2;
  inline bool has_buyerid() const;
  inline void clear_buyerid();
  static const int kBuyeridFieldNumber = 2;
  inline const ::std::string& buyerid() const;
  inline void set_buyerid(const ::std::string& value);
  inline void set_buyerid(const char* value);
  inline void set_buyerid(const char* value, size_t size);
  inline ::std::string* mutable_buyerid();
  inline ::std::string* release_buyerid();
  inline void set_allocated_buyerid(::std::string* buyerid);

  // optional string gender = 3;
  inline bool has_gender() const;
  inline void clear_gender();
  static const int kGenderFieldNumber = 3;
  inline const ::std::string& gender() const;
  inline void set_gender(const ::std::string& value);
  inline void set_gender(const char* value);
  inline void set_gender(const char* value, size_t size);
  inline ::std::string* mutable_gender();
  inline ::std::string* release_gender();
  inline void set_allocated_gender(::std::string* gender);

  // optional uint32 age = 4;
  inline bool has_age() const;
  inline void clear_age();
  static const int kAgeFieldNumber = 4;
  inline ::google::protobuf::uint32 age() const;
  inline void set_age(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TENC.Request.User)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_buyerid();
  inline void clear_has_buyerid();
  inline void set_has_gender();
  inline void clear_has_gender();
  inline void set_has_age();
  inline void clear_has_age();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* buyerid_;
  ::std::string* gender_;
  ::google::protobuf::uint32 age_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_tenc_2dbidding_2eproto();
  friend void protobuf_AssignDesc_tenc_2dbidding_2eproto();
  friend void protobuf_ShutdownFile_tenc_2dbidding_2eproto();

  void InitAsDefaultInstance();
  static Request_User* default_instance_;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Request_Impression Impression;
  typedef Request_Site Site;
  typedef Request_Device Device;
  typedef Request_User User;

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional uint32 at = 2;
  inline bool has_at() const;
  inline void clear_at();
  static const int kAtFieldNumber = 2;
  inline ::google::protobuf::uint32 at() const;
  inline void set_at(::google::protobuf::uint32 value);

  // optional .TENC.Request.Site site = 3;
  inline bool has_site() const;
  inline void clear_site();
  static const int kSiteFieldNumber = 3;
  inline const ::TENC::Request_Site& site() const;
  inline ::TENC::Request_Site* mutable_site();
  inline ::TENC::Request_Site* release_site();
  inline void set_allocated_site(::TENC::Request_Site* site);

  // optional .TENC.Request.Device device = 4;
  inline bool has_device() const;
  inline void clear_device();
  static const int kDeviceFieldNumber = 4;
  inline const ::TENC::Request_Device& device() const;
  inline ::TENC::Request_Device* mutable_device();
  inline ::TENC::Request_Device* release_device();
  inline void set_allocated_device(::TENC::Request_Device* device);

  // optional .TENC.Request.User user = 5;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 5;
  inline const ::TENC::Request_User& user() const;
  inline ::TENC::Request_User* mutable_user();
  inline ::TENC::Request_User* release_user();
  inline void set_allocated_user(::TENC::Request_User* user);

  // repeated .TENC.Request.Impression impression = 6;
  inline int impression_size() const;
  inline void clear_impression();
  static const int kImpressionFieldNumber = 6;
  inline const ::TENC::Request_Impression& impression(int index) const;
  inline ::TENC::Request_Impression* mutable_impression(int index);
  inline ::TENC::Request_Impression* add_impression();
  inline const ::google::protobuf::RepeatedPtrField< ::TENC::Request_Impression >&
      impression() const;
  inline ::google::protobuf::RepeatedPtrField< ::TENC::Request_Impression >*
      mutable_impression();

  // @@protoc_insertion_point(class_scope:TENC.Request)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_at();
  inline void clear_has_at();
  inline void set_has_site();
  inline void clear_has_site();
  inline void set_has_device();
  inline void clear_has_device();
  inline void set_has_user();
  inline void clear_has_user();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::TENC::Request_Site* site_;
  ::TENC::Request_Device* device_;
  ::TENC::Request_User* user_;
  ::google::protobuf::RepeatedPtrField< ::TENC::Request_Impression > impression_;
  ::google::protobuf::uint32 at_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_tenc_2dbidding_2eproto();
  friend void protobuf_AssignDesc_tenc_2dbidding_2eproto();
  friend void protobuf_ShutdownFile_tenc_2dbidding_2eproto();

  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Response_Bid : public ::google::protobuf::Message {
 public:
  Response_Bid();
  virtual ~Response_Bid();

  Response_Bid(const Response_Bid& from);

  inline Response_Bid& operator=(const Response_Bid& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_Bid& default_instance();

  void Swap(Response_Bid* other);

  // implements Message ----------------------------------------------

  Response_Bid* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response_Bid& from);
  void MergeFrom(const Response_Bid& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string impid = 2;
  inline bool has_impid() const;
  inline void clear_impid();
  static const int kImpidFieldNumber = 2;
  inline const ::std::string& impid() const;
  inline void set_impid(const ::std::string& value);
  inline void set_impid(const char* value);
  inline void set_impid(const char* value, size_t size);
  inline ::std::string* mutable_impid();
  inline ::std::string* release_impid();
  inline void set_allocated_impid(::std::string* impid);

  // optional float price = 3;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 3;
  inline float price() const;
  inline void set_price(float value);

  // optional string adid = 4;
  inline bool has_adid() const;
  inline void clear_adid();
  static const int kAdidFieldNumber = 4;
  inline const ::std::string& adid() const;
  inline void set_adid(const ::std::string& value);
  inline void set_adid(const char* value);
  inline void set_adid(const char* value, size_t size);
  inline ::std::string* mutable_adid();
  inline ::std::string* release_adid();
  inline void set_allocated_adid(::std::string* adid);

  // optional string nurl = 5;
  inline bool has_nurl() const;
  inline void clear_nurl();
  static const int kNurlFieldNumber = 5;
  inline const ::std::string& nurl() const;
  inline void set_nurl(const ::std::string& value);
  inline void set_nurl(const char* value);
  inline void set_nurl(const char* value, size_t size);
  inline ::std::string* mutable_nurl();
  inline ::std::string* release_nurl();
  inline void set_allocated_nurl(::std::string* nurl);

  // optional string adm = 6;
  inline bool has_adm() const;
  inline void clear_adm();
  static const int kAdmFieldNumber = 6;
  inline const ::std::string& adm() const;
  inline void set_adm(const ::std::string& value);
  inline void set_adm(const char* value);
  inline void set_adm(const char* value, size_t size);
  inline ::std::string* mutable_adm();
  inline ::std::string* release_adm();
  inline void set_allocated_adm(::std::string* adm);

  // optional string ext = 7;
  inline bool has_ext() const;
  inline void clear_ext();
  static const int kExtFieldNumber = 7;
  inline const ::std::string& ext() const;
  inline void set_ext(const ::std::string& value);
  inline void set_ext(const char* value);
  inline void set_ext(const char* value, size_t size);
  inline ::std::string* mutable_ext();
  inline ::std::string* release_ext();
  inline void set_allocated_ext(::std::string* ext);

  // optional string adm_para = 8;
  inline bool has_adm_para() const;
  inline void clear_adm_para();
  static const int kAdmParaFieldNumber = 8;
  inline const ::std::string& adm_para() const;
  inline void set_adm_para(const ::std::string& value);
  inline void set_adm_para(const char* value);
  inline void set_adm_para(const char* value, size_t size);
  inline ::std::string* mutable_adm_para();
  inline ::std::string* release_adm_para();
  inline void set_allocated_adm_para(::std::string* adm_para);

  // @@protoc_insertion_point(class_scope:TENC.Response.Bid)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_impid();
  inline void clear_has_impid();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_adid();
  inline void clear_has_adid();
  inline void set_has_nurl();
  inline void clear_has_nurl();
  inline void set_has_adm();
  inline void clear_has_adm();
  inline void set_has_ext();
  inline void clear_has_ext();
  inline void set_has_adm_para();
  inline void clear_has_adm_para();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* impid_;
  ::std::string* adid_;
  ::std::string* nurl_;
  ::std::string* adm_;
  ::std::string* ext_;
  ::std::string* adm_para_;
  float price_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_tenc_2dbidding_2eproto();
  friend void protobuf_AssignDesc_tenc_2dbidding_2eproto();
  friend void protobuf_ShutdownFile_tenc_2dbidding_2eproto();

  void InitAsDefaultInstance();
  static Response_Bid* default_instance_;
};
// -------------------------------------------------------------------

class Response_SeatBid : public ::google::protobuf::Message {
 public:
  Response_SeatBid();
  virtual ~Response_SeatBid();

  Response_SeatBid(const Response_SeatBid& from);

  inline Response_SeatBid& operator=(const Response_SeatBid& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_SeatBid& default_instance();

  void Swap(Response_SeatBid* other);

  // implements Message ----------------------------------------------

  Response_SeatBid* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response_SeatBid& from);
  void MergeFrom(const Response_SeatBid& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TENC.Response.Bid bid = 1;
  inline int bid_size() const;
  inline void clear_bid();
  static const int kBidFieldNumber = 1;
  inline const ::TENC::Response_Bid& bid(int index) const;
  inline ::TENC::Response_Bid* mutable_bid(int index);
  inline ::TENC::Response_Bid* add_bid();
  inline const ::google::protobuf::RepeatedPtrField< ::TENC::Response_Bid >&
      bid() const;
  inline ::google::protobuf::RepeatedPtrField< ::TENC::Response_Bid >*
      mutable_bid();

  // @@protoc_insertion_point(class_scope:TENC.Response.SeatBid)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TENC::Response_Bid > bid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_tenc_2dbidding_2eproto();
  friend void protobuf_AssignDesc_tenc_2dbidding_2eproto();
  friend void protobuf_ShutdownFile_tenc_2dbidding_2eproto();

  void InitAsDefaultInstance();
  static Response_SeatBid* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  Response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Response_Bid Bid;
  typedef Response_SeatBid SeatBid;

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string bidid = 2;
  inline bool has_bidid() const;
  inline void clear_bidid();
  static const int kBididFieldNumber = 2;
  inline const ::std::string& bidid() const;
  inline void set_bidid(const ::std::string& value);
  inline void set_bidid(const char* value);
  inline void set_bidid(const char* value, size_t size);
  inline ::std::string* mutable_bidid();
  inline ::std::string* release_bidid();
  inline void set_allocated_bidid(::std::string* bidid);

  // repeated .TENC.Response.SeatBid seatbid = 3;
  inline int seatbid_size() const;
  inline void clear_seatbid();
  static const int kSeatbidFieldNumber = 3;
  inline const ::TENC::Response_SeatBid& seatbid(int index) const;
  inline ::TENC::Response_SeatBid* mutable_seatbid(int index);
  inline ::TENC::Response_SeatBid* add_seatbid();
  inline const ::google::protobuf::RepeatedPtrField< ::TENC::Response_SeatBid >&
      seatbid() const;
  inline ::google::protobuf::RepeatedPtrField< ::TENC::Response_SeatBid >*
      mutable_seatbid();

  // @@protoc_insertion_point(class_scope:TENC.Response)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_bidid();
  inline void clear_has_bidid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* bidid_;
  ::google::protobuf::RepeatedPtrField< ::TENC::Response_SeatBid > seatbid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_tenc_2dbidding_2eproto();
  friend void protobuf_AssignDesc_tenc_2dbidding_2eproto();
  friend void protobuf_ShutdownFile_tenc_2dbidding_2eproto();

  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// ===================================================================


// ===================================================================

// Request_Impression_Banner

// optional uint32 width = 1;
inline bool Request_Impression_Banner::has_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_Impression_Banner::set_has_width() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_Impression_Banner::clear_has_width() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_Impression_Banner::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 Request_Impression_Banner::width() const {
  return width_;
}
inline void Request_Impression_Banner::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
}

// optional uint32 height = 2;
inline bool Request_Impression_Banner::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request_Impression_Banner::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request_Impression_Banner::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request_Impression_Banner::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 Request_Impression_Banner::height() const {
  return height_;
}
inline void Request_Impression_Banner::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
}

// repeated string mimes = 3;
inline int Request_Impression_Banner::mimes_size() const {
  return mimes_.size();
}
inline void Request_Impression_Banner::clear_mimes() {
  mimes_.Clear();
}
inline const ::std::string& Request_Impression_Banner::mimes(int index) const {
  return mimes_.Get(index);
}
inline ::std::string* Request_Impression_Banner::mutable_mimes(int index) {
  return mimes_.Mutable(index);
}
inline void Request_Impression_Banner::set_mimes(int index, const ::std::string& value) {
  mimes_.Mutable(index)->assign(value);
}
inline void Request_Impression_Banner::set_mimes(int index, const char* value) {
  mimes_.Mutable(index)->assign(value);
}
inline void Request_Impression_Banner::set_mimes(int index, const char* value, size_t size) {
  mimes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request_Impression_Banner::add_mimes() {
  return mimes_.Add();
}
inline void Request_Impression_Banner::add_mimes(const ::std::string& value) {
  mimes_.Add()->assign(value);
}
inline void Request_Impression_Banner::add_mimes(const char* value) {
  mimes_.Add()->assign(value);
}
inline void Request_Impression_Banner::add_mimes(const char* value, size_t size) {
  mimes_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Request_Impression_Banner::mimes() const {
  return mimes_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Request_Impression_Banner::mutable_mimes() {
  return &mimes_;
}

// optional string extra_style = 4;
inline bool Request_Impression_Banner::has_extra_style() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request_Impression_Banner::set_has_extra_style() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request_Impression_Banner::clear_has_extra_style() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request_Impression_Banner::clear_extra_style() {
  if (extra_style_ != &::google::protobuf::internal::kEmptyString) {
    extra_style_->clear();
  }
  clear_has_extra_style();
}
inline const ::std::string& Request_Impression_Banner::extra_style() const {
  return *extra_style_;
}
inline void Request_Impression_Banner::set_extra_style(const ::std::string& value) {
  set_has_extra_style();
  if (extra_style_ == &::google::protobuf::internal::kEmptyString) {
    extra_style_ = new ::std::string;
  }
  extra_style_->assign(value);
}
inline void Request_Impression_Banner::set_extra_style(const char* value) {
  set_has_extra_style();
  if (extra_style_ == &::google::protobuf::internal::kEmptyString) {
    extra_style_ = new ::std::string;
  }
  extra_style_->assign(value);
}
inline void Request_Impression_Banner::set_extra_style(const char* value, size_t size) {
  set_has_extra_style();
  if (extra_style_ == &::google::protobuf::internal::kEmptyString) {
    extra_style_ = new ::std::string;
  }
  extra_style_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request_Impression_Banner::mutable_extra_style() {
  set_has_extra_style();
  if (extra_style_ == &::google::protobuf::internal::kEmptyString) {
    extra_style_ = new ::std::string;
  }
  return extra_style_;
}
inline ::std::string* Request_Impression_Banner::release_extra_style() {
  clear_has_extra_style();
  if (extra_style_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extra_style_;
    extra_style_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request_Impression_Banner::set_allocated_extra_style(::std::string* extra_style) {
  if (extra_style_ != &::google::protobuf::internal::kEmptyString) {
    delete extra_style_;
  }
  if (extra_style) {
    set_has_extra_style();
    extra_style_ = extra_style;
  } else {
    clear_has_extra_style();
    extra_style_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 visibility = 5;
inline bool Request_Impression_Banner::has_visibility() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Request_Impression_Banner::set_has_visibility() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Request_Impression_Banner::clear_has_visibility() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Request_Impression_Banner::clear_visibility() {
  visibility_ = 0u;
  clear_has_visibility();
}
inline ::google::protobuf::uint32 Request_Impression_Banner::visibility() const {
  return visibility_;
}
inline void Request_Impression_Banner::set_visibility(::google::protobuf::uint32 value) {
  set_has_visibility();
  visibility_ = value;
}

// -------------------------------------------------------------------

// Request_Impression_Video

// repeated string mimes = 1;
inline int Request_Impression_Video::mimes_size() const {
  return mimes_.size();
}
inline void Request_Impression_Video::clear_mimes() {
  mimes_.Clear();
}
inline const ::std::string& Request_Impression_Video::mimes(int index) const {
  return mimes_.Get(index);
}
inline ::std::string* Request_Impression_Video::mutable_mimes(int index) {
  return mimes_.Mutable(index);
}
inline void Request_Impression_Video::set_mimes(int index, const ::std::string& value) {
  mimes_.Mutable(index)->assign(value);
}
inline void Request_Impression_Video::set_mimes(int index, const char* value) {
  mimes_.Mutable(index)->assign(value);
}
inline void Request_Impression_Video::set_mimes(int index, const char* value, size_t size) {
  mimes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request_Impression_Video::add_mimes() {
  return mimes_.Add();
}
inline void Request_Impression_Video::add_mimes(const ::std::string& value) {
  mimes_.Add()->assign(value);
}
inline void Request_Impression_Video::add_mimes(const char* value) {
  mimes_.Add()->assign(value);
}
inline void Request_Impression_Video::add_mimes(const char* value, size_t size) {
  mimes_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Request_Impression_Video::mimes() const {
  return mimes_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Request_Impression_Video::mutable_mimes() {
  return &mimes_;
}

// optional uint32 linearity = 2;
inline bool Request_Impression_Video::has_linearity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request_Impression_Video::set_has_linearity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request_Impression_Video::clear_has_linearity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request_Impression_Video::clear_linearity() {
  linearity_ = 0u;
  clear_has_linearity();
}
inline ::google::protobuf::uint32 Request_Impression_Video::linearity() const {
  return linearity_;
}
inline void Request_Impression_Video::set_linearity(::google::protobuf::uint32 value) {
  set_has_linearity();
  linearity_ = value;
}

// optional uint32 minduration = 3;
inline bool Request_Impression_Video::has_minduration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request_Impression_Video::set_has_minduration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request_Impression_Video::clear_has_minduration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request_Impression_Video::clear_minduration() {
  minduration_ = 0u;
  clear_has_minduration();
}
inline ::google::protobuf::uint32 Request_Impression_Video::minduration() const {
  return minduration_;
}
inline void Request_Impression_Video::set_minduration(::google::protobuf::uint32 value) {
  set_has_minduration();
  minduration_ = value;
}

// optional uint32 maxduration = 4;
inline bool Request_Impression_Video::has_maxduration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request_Impression_Video::set_has_maxduration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request_Impression_Video::clear_has_maxduration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request_Impression_Video::clear_maxduration() {
  maxduration_ = 0u;
  clear_has_maxduration();
}
inline ::google::protobuf::uint32 Request_Impression_Video::maxduration() const {
  return maxduration_;
}
inline void Request_Impression_Video::set_maxduration(::google::protobuf::uint32 value) {
  set_has_maxduration();
  maxduration_ = value;
}

// optional uint32 protocol = 5;
inline bool Request_Impression_Video::has_protocol() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Request_Impression_Video::set_has_protocol() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Request_Impression_Video::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Request_Impression_Video::clear_protocol() {
  protocol_ = 0u;
  clear_has_protocol();
}
inline ::google::protobuf::uint32 Request_Impression_Video::protocol() const {
  return protocol_;
}
inline void Request_Impression_Video::set_protocol(::google::protobuf::uint32 value) {
  set_has_protocol();
  protocol_ = value;
}

// optional uint32 width = 6;
inline bool Request_Impression_Video::has_width() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Request_Impression_Video::set_has_width() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Request_Impression_Video::clear_has_width() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Request_Impression_Video::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 Request_Impression_Video::width() const {
  return width_;
}
inline void Request_Impression_Video::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
}

// optional uint32 height = 7;
inline bool Request_Impression_Video::has_height() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Request_Impression_Video::set_has_height() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Request_Impression_Video::clear_has_height() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Request_Impression_Video::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 Request_Impression_Video::height() const {
  return height_;
}
inline void Request_Impression_Video::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
}

// -------------------------------------------------------------------

// Request_Impression

// optional string id = 1;
inline bool Request_Impression::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_Impression::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_Impression::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_Impression::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Request_Impression::id() const {
  return *id_;
}
inline void Request_Impression::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Request_Impression::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Request_Impression::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request_Impression::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* Request_Impression::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request_Impression::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string tagid = 2;
inline bool Request_Impression::has_tagid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request_Impression::set_has_tagid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request_Impression::clear_has_tagid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request_Impression::clear_tagid() {
  if (tagid_ != &::google::protobuf::internal::kEmptyString) {
    tagid_->clear();
  }
  clear_has_tagid();
}
inline const ::std::string& Request_Impression::tagid() const {
  return *tagid_;
}
inline void Request_Impression::set_tagid(const ::std::string& value) {
  set_has_tagid();
  if (tagid_ == &::google::protobuf::internal::kEmptyString) {
    tagid_ = new ::std::string;
  }
  tagid_->assign(value);
}
inline void Request_Impression::set_tagid(const char* value) {
  set_has_tagid();
  if (tagid_ == &::google::protobuf::internal::kEmptyString) {
    tagid_ = new ::std::string;
  }
  tagid_->assign(value);
}
inline void Request_Impression::set_tagid(const char* value, size_t size) {
  set_has_tagid();
  if (tagid_ == &::google::protobuf::internal::kEmptyString) {
    tagid_ = new ::std::string;
  }
  tagid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request_Impression::mutable_tagid() {
  set_has_tagid();
  if (tagid_ == &::google::protobuf::internal::kEmptyString) {
    tagid_ = new ::std::string;
  }
  return tagid_;
}
inline ::std::string* Request_Impression::release_tagid() {
  clear_has_tagid();
  if (tagid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tagid_;
    tagid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request_Impression::set_allocated_tagid(::std::string* tagid) {
  if (tagid_ != &::google::protobuf::internal::kEmptyString) {
    delete tagid_;
  }
  if (tagid) {
    set_has_tagid();
    tagid_ = tagid;
  } else {
    clear_has_tagid();
    tagid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float bidfloor = 3;
inline bool Request_Impression::has_bidfloor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request_Impression::set_has_bidfloor() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request_Impression::clear_has_bidfloor() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request_Impression::clear_bidfloor() {
  bidfloor_ = 0;
  clear_has_bidfloor();
}
inline float Request_Impression::bidfloor() const {
  return bidfloor_;
}
inline void Request_Impression::set_bidfloor(float value) {
  set_has_bidfloor();
  bidfloor_ = value;
}

// optional .TENC.Request.Impression.Banner banner = 4;
inline bool Request_Impression::has_banner() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request_Impression::set_has_banner() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request_Impression::clear_has_banner() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request_Impression::clear_banner() {
  if (banner_ != NULL) banner_->::TENC::Request_Impression_Banner::Clear();
  clear_has_banner();
}
inline const ::TENC::Request_Impression_Banner& Request_Impression::banner() const {
  return banner_ != NULL ? *banner_ : *default_instance_->banner_;
}
inline ::TENC::Request_Impression_Banner* Request_Impression::mutable_banner() {
  set_has_banner();
  if (banner_ == NULL) banner_ = new ::TENC::Request_Impression_Banner;
  return banner_;
}
inline ::TENC::Request_Impression_Banner* Request_Impression::release_banner() {
  clear_has_banner();
  ::TENC::Request_Impression_Banner* temp = banner_;
  banner_ = NULL;
  return temp;
}
inline void Request_Impression::set_allocated_banner(::TENC::Request_Impression_Banner* banner) {
  delete banner_;
  banner_ = banner;
  if (banner) {
    set_has_banner();
  } else {
    clear_has_banner();
  }
}

// optional .TENC.Request.Impression.Video video = 5;
inline bool Request_Impression::has_video() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Request_Impression::set_has_video() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Request_Impression::clear_has_video() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Request_Impression::clear_video() {
  if (video_ != NULL) video_->::TENC::Request_Impression_Video::Clear();
  clear_has_video();
}
inline const ::TENC::Request_Impression_Video& Request_Impression::video() const {
  return video_ != NULL ? *video_ : *default_instance_->video_;
}
inline ::TENC::Request_Impression_Video* Request_Impression::mutable_video() {
  set_has_video();
  if (video_ == NULL) video_ = new ::TENC::Request_Impression_Video;
  return video_;
}
inline ::TENC::Request_Impression_Video* Request_Impression::release_video() {
  clear_has_video();
  ::TENC::Request_Impression_Video* temp = video_;
  video_ = NULL;
  return temp;
}
inline void Request_Impression::set_allocated_video(::TENC::Request_Impression_Video* video) {
  delete video_;
  video_ = video;
  if (video) {
    set_has_video();
  } else {
    clear_has_video();
  }
}

// optional string clientid = 6;
inline bool Request_Impression::has_clientid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Request_Impression::set_has_clientid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Request_Impression::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Request_Impression::clear_clientid() {
  if (clientid_ != &::google::protobuf::internal::kEmptyString) {
    clientid_->clear();
  }
  clear_has_clientid();
}
inline const ::std::string& Request_Impression::clientid() const {
  return *clientid_;
}
inline void Request_Impression::set_clientid(const ::std::string& value) {
  set_has_clientid();
  if (clientid_ == &::google::protobuf::internal::kEmptyString) {
    clientid_ = new ::std::string;
  }
  clientid_->assign(value);
}
inline void Request_Impression::set_clientid(const char* value) {
  set_has_clientid();
  if (clientid_ == &::google::protobuf::internal::kEmptyString) {
    clientid_ = new ::std::string;
  }
  clientid_->assign(value);
}
inline void Request_Impression::set_clientid(const char* value, size_t size) {
  set_has_clientid();
  if (clientid_ == &::google::protobuf::internal::kEmptyString) {
    clientid_ = new ::std::string;
  }
  clientid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request_Impression::mutable_clientid() {
  set_has_clientid();
  if (clientid_ == &::google::protobuf::internal::kEmptyString) {
    clientid_ = new ::std::string;
  }
  return clientid_;
}
inline ::std::string* Request_Impression::release_clientid() {
  clear_has_clientid();
  if (clientid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clientid_;
    clientid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request_Impression::set_allocated_clientid(::std::string* clientid) {
  if (clientid_ != &::google::protobuf::internal::kEmptyString) {
    delete clientid_;
  }
  if (clientid) {
    set_has_clientid();
    clientid_ = clientid;
  } else {
    clear_has_clientid();
    clientid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string tradecode = 7;
inline bool Request_Impression::has_tradecode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Request_Impression::set_has_tradecode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Request_Impression::clear_has_tradecode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Request_Impression::clear_tradecode() {
  if (tradecode_ != &::google::protobuf::internal::kEmptyString) {
    tradecode_->clear();
  }
  clear_has_tradecode();
}
inline const ::std::string& Request_Impression::tradecode() const {
  return *tradecode_;
}
inline void Request_Impression::set_tradecode(const ::std::string& value) {
  set_has_tradecode();
  if (tradecode_ == &::google::protobuf::internal::kEmptyString) {
    tradecode_ = new ::std::string;
  }
  tradecode_->assign(value);
}
inline void Request_Impression::set_tradecode(const char* value) {
  set_has_tradecode();
  if (tradecode_ == &::google::protobuf::internal::kEmptyString) {
    tradecode_ = new ::std::string;
  }
  tradecode_->assign(value);
}
inline void Request_Impression::set_tradecode(const char* value, size_t size) {
  set_has_tradecode();
  if (tradecode_ == &::google::protobuf::internal::kEmptyString) {
    tradecode_ = new ::std::string;
  }
  tradecode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request_Impression::mutable_tradecode() {
  set_has_tradecode();
  if (tradecode_ == &::google::protobuf::internal::kEmptyString) {
    tradecode_ = new ::std::string;
  }
  return tradecode_;
}
inline ::std::string* Request_Impression::release_tradecode() {
  clear_has_tradecode();
  if (tradecode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tradecode_;
    tradecode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request_Impression::set_allocated_tradecode(::std::string* tradecode) {
  if (tradecode_ != &::google::protobuf::internal::kEmptyString) {
    delete tradecode_;
  }
  if (tradecode) {
    set_has_tradecode();
    tradecode_ = tradecode;
  } else {
    clear_has_tradecode();
    tradecode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sns_lists = 8;
inline bool Request_Impression::has_sns_lists() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Request_Impression::set_has_sns_lists() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Request_Impression::clear_has_sns_lists() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Request_Impression::clear_sns_lists() {
  if (sns_lists_ != &::google::protobuf::internal::kEmptyString) {
    sns_lists_->clear();
  }
  clear_has_sns_lists();
}
inline const ::std::string& Request_Impression::sns_lists() const {
  return *sns_lists_;
}
inline void Request_Impression::set_sns_lists(const ::std::string& value) {
  set_has_sns_lists();
  if (sns_lists_ == &::google::protobuf::internal::kEmptyString) {
    sns_lists_ = new ::std::string;
  }
  sns_lists_->assign(value);
}
inline void Request_Impression::set_sns_lists(const char* value) {
  set_has_sns_lists();
  if (sns_lists_ == &::google::protobuf::internal::kEmptyString) {
    sns_lists_ = new ::std::string;
  }
  sns_lists_->assign(value);
}
inline void Request_Impression::set_sns_lists(const char* value, size_t size) {
  set_has_sns_lists();
  if (sns_lists_ == &::google::protobuf::internal::kEmptyString) {
    sns_lists_ = new ::std::string;
  }
  sns_lists_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request_Impression::mutable_sns_lists() {
  set_has_sns_lists();
  if (sns_lists_ == &::google::protobuf::internal::kEmptyString) {
    sns_lists_ = new ::std::string;
  }
  return sns_lists_;
}
inline ::std::string* Request_Impression::release_sns_lists() {
  clear_has_sns_lists();
  if (sns_lists_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sns_lists_;
    sns_lists_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request_Impression::set_allocated_sns_lists(::std::string* sns_lists) {
  if (sns_lists_ != &::google::protobuf::internal::kEmptyString) {
    delete sns_lists_;
  }
  if (sns_lists) {
    set_has_sns_lists();
    sns_lists_ = sns_lists;
  } else {
    clear_has_sns_lists();
    sns_lists_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Request_Site

// optional string name = 1;
inline bool Request_Site::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_Site::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_Site::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_Site::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Request_Site::name() const {
  return *name_;
}
inline void Request_Site::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Request_Site::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Request_Site::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request_Site::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Request_Site::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request_Site::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string page = 2;
inline bool Request_Site::has_page() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request_Site::set_has_page() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request_Site::clear_has_page() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request_Site::clear_page() {
  if (page_ != &::google::protobuf::internal::kEmptyString) {
    page_->clear();
  }
  clear_has_page();
}
inline const ::std::string& Request_Site::page() const {
  return *page_;
}
inline void Request_Site::set_page(const ::std::string& value) {
  set_has_page();
  if (page_ == &::google::protobuf::internal::kEmptyString) {
    page_ = new ::std::string;
  }
  page_->assign(value);
}
inline void Request_Site::set_page(const char* value) {
  set_has_page();
  if (page_ == &::google::protobuf::internal::kEmptyString) {
    page_ = new ::std::string;
  }
  page_->assign(value);
}
inline void Request_Site::set_page(const char* value, size_t size) {
  set_has_page();
  if (page_ == &::google::protobuf::internal::kEmptyString) {
    page_ = new ::std::string;
  }
  page_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request_Site::mutable_page() {
  set_has_page();
  if (page_ == &::google::protobuf::internal::kEmptyString) {
    page_ = new ::std::string;
  }
  return page_;
}
inline ::std::string* Request_Site::release_page() {
  clear_has_page();
  if (page_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = page_;
    page_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request_Site::set_allocated_page(::std::string* page) {
  if (page_ != &::google::protobuf::internal::kEmptyString) {
    delete page_;
  }
  if (page) {
    set_has_page();
    page_ = page;
  } else {
    clear_has_page();
    page_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ref = 3;
inline bool Request_Site::has_ref() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request_Site::set_has_ref() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request_Site::clear_has_ref() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request_Site::clear_ref() {
  if (ref_ != &::google::protobuf::internal::kEmptyString) {
    ref_->clear();
  }
  clear_has_ref();
}
inline const ::std::string& Request_Site::ref() const {
  return *ref_;
}
inline void Request_Site::set_ref(const ::std::string& value) {
  set_has_ref();
  if (ref_ == &::google::protobuf::internal::kEmptyString) {
    ref_ = new ::std::string;
  }
  ref_->assign(value);
}
inline void Request_Site::set_ref(const char* value) {
  set_has_ref();
  if (ref_ == &::google::protobuf::internal::kEmptyString) {
    ref_ = new ::std::string;
  }
  ref_->assign(value);
}
inline void Request_Site::set_ref(const char* value, size_t size) {
  set_has_ref();
  if (ref_ == &::google::protobuf::internal::kEmptyString) {
    ref_ = new ::std::string;
  }
  ref_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request_Site::mutable_ref() {
  set_has_ref();
  if (ref_ == &::google::protobuf::internal::kEmptyString) {
    ref_ = new ::std::string;
  }
  return ref_;
}
inline ::std::string* Request_Site::release_ref() {
  clear_has_ref();
  if (ref_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ref_;
    ref_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request_Site::set_allocated_ref(::std::string* ref) {
  if (ref_ != &::google::protobuf::internal::kEmptyString) {
    delete ref_;
  }
  if (ref) {
    set_has_ref();
    ref_ = ref;
  } else {
    clear_has_ref();
    ref_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Request_Device

// optional string ip = 1;
inline bool Request_Device::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_Device::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_Device::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_Device::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& Request_Device::ip() const {
  return *ip_;
}
inline void Request_Device::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void Request_Device::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void Request_Device::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request_Device::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* Request_Device::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request_Device::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ua = 2;
inline bool Request_Device::has_ua() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request_Device::set_has_ua() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request_Device::clear_has_ua() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request_Device::clear_ua() {
  if (ua_ != &::google::protobuf::internal::kEmptyString) {
    ua_->clear();
  }
  clear_has_ua();
}
inline const ::std::string& Request_Device::ua() const {
  return *ua_;
}
inline void Request_Device::set_ua(const ::std::string& value) {
  set_has_ua();
  if (ua_ == &::google::protobuf::internal::kEmptyString) {
    ua_ = new ::std::string;
  }
  ua_->assign(value);
}
inline void Request_Device::set_ua(const char* value) {
  set_has_ua();
  if (ua_ == &::google::protobuf::internal::kEmptyString) {
    ua_ = new ::std::string;
  }
  ua_->assign(value);
}
inline void Request_Device::set_ua(const char* value, size_t size) {
  set_has_ua();
  if (ua_ == &::google::protobuf::internal::kEmptyString) {
    ua_ = new ::std::string;
  }
  ua_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request_Device::mutable_ua() {
  set_has_ua();
  if (ua_ == &::google::protobuf::internal::kEmptyString) {
    ua_ = new ::std::string;
  }
  return ua_;
}
inline ::std::string* Request_Device::release_ua() {
  clear_has_ua();
  if (ua_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ua_;
    ua_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request_Device::set_allocated_ua(::std::string* ua) {
  if (ua_ != &::google::protobuf::internal::kEmptyString) {
    delete ua_;
  }
  if (ua) {
    set_has_ua();
    ua_ = ua;
  } else {
    clear_has_ua();
    ua_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Request_User

// optional string id = 1;
inline bool Request_User::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_User::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_User::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_User::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Request_User::id() const {
  return *id_;
}
inline void Request_User::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Request_User::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Request_User::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request_User::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* Request_User::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request_User::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string buyerid = 2;
inline bool Request_User::has_buyerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request_User::set_has_buyerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request_User::clear_has_buyerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request_User::clear_buyerid() {
  if (buyerid_ != &::google::protobuf::internal::kEmptyString) {
    buyerid_->clear();
  }
  clear_has_buyerid();
}
inline const ::std::string& Request_User::buyerid() const {
  return *buyerid_;
}
inline void Request_User::set_buyerid(const ::std::string& value) {
  set_has_buyerid();
  if (buyerid_ == &::google::protobuf::internal::kEmptyString) {
    buyerid_ = new ::std::string;
  }
  buyerid_->assign(value);
}
inline void Request_User::set_buyerid(const char* value) {
  set_has_buyerid();
  if (buyerid_ == &::google::protobuf::internal::kEmptyString) {
    buyerid_ = new ::std::string;
  }
  buyerid_->assign(value);
}
inline void Request_User::set_buyerid(const char* value, size_t size) {
  set_has_buyerid();
  if (buyerid_ == &::google::protobuf::internal::kEmptyString) {
    buyerid_ = new ::std::string;
  }
  buyerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request_User::mutable_buyerid() {
  set_has_buyerid();
  if (buyerid_ == &::google::protobuf::internal::kEmptyString) {
    buyerid_ = new ::std::string;
  }
  return buyerid_;
}
inline ::std::string* Request_User::release_buyerid() {
  clear_has_buyerid();
  if (buyerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buyerid_;
    buyerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request_User::set_allocated_buyerid(::std::string* buyerid) {
  if (buyerid_ != &::google::protobuf::internal::kEmptyString) {
    delete buyerid_;
  }
  if (buyerid) {
    set_has_buyerid();
    buyerid_ = buyerid;
  } else {
    clear_has_buyerid();
    buyerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string gender = 3;
inline bool Request_User::has_gender() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request_User::set_has_gender() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request_User::clear_has_gender() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request_User::clear_gender() {
  if (gender_ != &::google::protobuf::internal::kEmptyString) {
    gender_->clear();
  }
  clear_has_gender();
}
inline const ::std::string& Request_User::gender() const {
  return *gender_;
}
inline void Request_User::set_gender(const ::std::string& value) {
  set_has_gender();
  if (gender_ == &::google::protobuf::internal::kEmptyString) {
    gender_ = new ::std::string;
  }
  gender_->assign(value);
}
inline void Request_User::set_gender(const char* value) {
  set_has_gender();
  if (gender_ == &::google::protobuf::internal::kEmptyString) {
    gender_ = new ::std::string;
  }
  gender_->assign(value);
}
inline void Request_User::set_gender(const char* value, size_t size) {
  set_has_gender();
  if (gender_ == &::google::protobuf::internal::kEmptyString) {
    gender_ = new ::std::string;
  }
  gender_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request_User::mutable_gender() {
  set_has_gender();
  if (gender_ == &::google::protobuf::internal::kEmptyString) {
    gender_ = new ::std::string;
  }
  return gender_;
}
inline ::std::string* Request_User::release_gender() {
  clear_has_gender();
  if (gender_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gender_;
    gender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request_User::set_allocated_gender(::std::string* gender) {
  if (gender_ != &::google::protobuf::internal::kEmptyString) {
    delete gender_;
  }
  if (gender) {
    set_has_gender();
    gender_ = gender;
  } else {
    clear_has_gender();
    gender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 age = 4;
inline bool Request_User::has_age() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request_User::set_has_age() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request_User::clear_has_age() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request_User::clear_age() {
  age_ = 0u;
  clear_has_age();
}
inline ::google::protobuf::uint32 Request_User::age() const {
  return age_;
}
inline void Request_User::set_age(::google::protobuf::uint32 value) {
  set_has_age();
  age_ = value;
}

// -------------------------------------------------------------------

// Request

// optional string id = 1;
inline bool Request::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Request::id() const {
  return *id_;
}
inline void Request::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Request::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Request::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* Request::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 at = 2;
inline bool Request::has_at() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request::set_has_at() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request::clear_has_at() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request::clear_at() {
  at_ = 0u;
  clear_has_at();
}
inline ::google::protobuf::uint32 Request::at() const {
  return at_;
}
inline void Request::set_at(::google::protobuf::uint32 value) {
  set_has_at();
  at_ = value;
}

// optional .TENC.Request.Site site = 3;
inline bool Request::has_site() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request::set_has_site() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request::clear_has_site() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request::clear_site() {
  if (site_ != NULL) site_->::TENC::Request_Site::Clear();
  clear_has_site();
}
inline const ::TENC::Request_Site& Request::site() const {
  return site_ != NULL ? *site_ : *default_instance_->site_;
}
inline ::TENC::Request_Site* Request::mutable_site() {
  set_has_site();
  if (site_ == NULL) site_ = new ::TENC::Request_Site;
  return site_;
}
inline ::TENC::Request_Site* Request::release_site() {
  clear_has_site();
  ::TENC::Request_Site* temp = site_;
  site_ = NULL;
  return temp;
}
inline void Request::set_allocated_site(::TENC::Request_Site* site) {
  delete site_;
  site_ = site;
  if (site) {
    set_has_site();
  } else {
    clear_has_site();
  }
}

// optional .TENC.Request.Device device = 4;
inline bool Request::has_device() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request::set_has_device() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request::clear_has_device() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request::clear_device() {
  if (device_ != NULL) device_->::TENC::Request_Device::Clear();
  clear_has_device();
}
inline const ::TENC::Request_Device& Request::device() const {
  return device_ != NULL ? *device_ : *default_instance_->device_;
}
inline ::TENC::Request_Device* Request::mutable_device() {
  set_has_device();
  if (device_ == NULL) device_ = new ::TENC::Request_Device;
  return device_;
}
inline ::TENC::Request_Device* Request::release_device() {
  clear_has_device();
  ::TENC::Request_Device* temp = device_;
  device_ = NULL;
  return temp;
}
inline void Request::set_allocated_device(::TENC::Request_Device* device) {
  delete device_;
  device_ = device;
  if (device) {
    set_has_device();
  } else {
    clear_has_device();
  }
}

// optional .TENC.Request.User user = 5;
inline bool Request::has_user() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Request::set_has_user() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Request::clear_has_user() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Request::clear_user() {
  if (user_ != NULL) user_->::TENC::Request_User::Clear();
  clear_has_user();
}
inline const ::TENC::Request_User& Request::user() const {
  return user_ != NULL ? *user_ : *default_instance_->user_;
}
inline ::TENC::Request_User* Request::mutable_user() {
  set_has_user();
  if (user_ == NULL) user_ = new ::TENC::Request_User;
  return user_;
}
inline ::TENC::Request_User* Request::release_user() {
  clear_has_user();
  ::TENC::Request_User* temp = user_;
  user_ = NULL;
  return temp;
}
inline void Request::set_allocated_user(::TENC::Request_User* user) {
  delete user_;
  user_ = user;
  if (user) {
    set_has_user();
  } else {
    clear_has_user();
  }
}

// repeated .TENC.Request.Impression impression = 6;
inline int Request::impression_size() const {
  return impression_.size();
}
inline void Request::clear_impression() {
  impression_.Clear();
}
inline const ::TENC::Request_Impression& Request::impression(int index) const {
  return impression_.Get(index);
}
inline ::TENC::Request_Impression* Request::mutable_impression(int index) {
  return impression_.Mutable(index);
}
inline ::TENC::Request_Impression* Request::add_impression() {
  return impression_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TENC::Request_Impression >&
Request::impression() const {
  return impression_;
}
inline ::google::protobuf::RepeatedPtrField< ::TENC::Request_Impression >*
Request::mutable_impression() {
  return &impression_;
}

// -------------------------------------------------------------------

// Response_Bid

// optional string id = 1;
inline bool Response_Bid::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_Bid::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_Bid::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_Bid::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Response_Bid::id() const {
  return *id_;
}
inline void Response_Bid::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Response_Bid::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Response_Bid::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Response_Bid::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* Response_Bid::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Response_Bid::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string impid = 2;
inline bool Response_Bid::has_impid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_Bid::set_has_impid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_Bid::clear_has_impid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_Bid::clear_impid() {
  if (impid_ != &::google::protobuf::internal::kEmptyString) {
    impid_->clear();
  }
  clear_has_impid();
}
inline const ::std::string& Response_Bid::impid() const {
  return *impid_;
}
inline void Response_Bid::set_impid(const ::std::string& value) {
  set_has_impid();
  if (impid_ == &::google::protobuf::internal::kEmptyString) {
    impid_ = new ::std::string;
  }
  impid_->assign(value);
}
inline void Response_Bid::set_impid(const char* value) {
  set_has_impid();
  if (impid_ == &::google::protobuf::internal::kEmptyString) {
    impid_ = new ::std::string;
  }
  impid_->assign(value);
}
inline void Response_Bid::set_impid(const char* value, size_t size) {
  set_has_impid();
  if (impid_ == &::google::protobuf::internal::kEmptyString) {
    impid_ = new ::std::string;
  }
  impid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Response_Bid::mutable_impid() {
  set_has_impid();
  if (impid_ == &::google::protobuf::internal::kEmptyString) {
    impid_ = new ::std::string;
  }
  return impid_;
}
inline ::std::string* Response_Bid::release_impid() {
  clear_has_impid();
  if (impid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = impid_;
    impid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Response_Bid::set_allocated_impid(::std::string* impid) {
  if (impid_ != &::google::protobuf::internal::kEmptyString) {
    delete impid_;
  }
  if (impid) {
    set_has_impid();
    impid_ = impid;
  } else {
    clear_has_impid();
    impid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float price = 3;
inline bool Response_Bid::has_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response_Bid::set_has_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response_Bid::clear_has_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response_Bid::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline float Response_Bid::price() const {
  return price_;
}
inline void Response_Bid::set_price(float value) {
  set_has_price();
  price_ = value;
}

// optional string adid = 4;
inline bool Response_Bid::has_adid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Response_Bid::set_has_adid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Response_Bid::clear_has_adid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Response_Bid::clear_adid() {
  if (adid_ != &::google::protobuf::internal::kEmptyString) {
    adid_->clear();
  }
  clear_has_adid();
}
inline const ::std::string& Response_Bid::adid() const {
  return *adid_;
}
inline void Response_Bid::set_adid(const ::std::string& value) {
  set_has_adid();
  if (adid_ == &::google::protobuf::internal::kEmptyString) {
    adid_ = new ::std::string;
  }
  adid_->assign(value);
}
inline void Response_Bid::set_adid(const char* value) {
  set_has_adid();
  if (adid_ == &::google::protobuf::internal::kEmptyString) {
    adid_ = new ::std::string;
  }
  adid_->assign(value);
}
inline void Response_Bid::set_adid(const char* value, size_t size) {
  set_has_adid();
  if (adid_ == &::google::protobuf::internal::kEmptyString) {
    adid_ = new ::std::string;
  }
  adid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Response_Bid::mutable_adid() {
  set_has_adid();
  if (adid_ == &::google::protobuf::internal::kEmptyString) {
    adid_ = new ::std::string;
  }
  return adid_;
}
inline ::std::string* Response_Bid::release_adid() {
  clear_has_adid();
  if (adid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = adid_;
    adid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Response_Bid::set_allocated_adid(::std::string* adid) {
  if (adid_ != &::google::protobuf::internal::kEmptyString) {
    delete adid_;
  }
  if (adid) {
    set_has_adid();
    adid_ = adid;
  } else {
    clear_has_adid();
    adid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string nurl = 5;
inline bool Response_Bid::has_nurl() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Response_Bid::set_has_nurl() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Response_Bid::clear_has_nurl() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Response_Bid::clear_nurl() {
  if (nurl_ != &::google::protobuf::internal::kEmptyString) {
    nurl_->clear();
  }
  clear_has_nurl();
}
inline const ::std::string& Response_Bid::nurl() const {
  return *nurl_;
}
inline void Response_Bid::set_nurl(const ::std::string& value) {
  set_has_nurl();
  if (nurl_ == &::google::protobuf::internal::kEmptyString) {
    nurl_ = new ::std::string;
  }
  nurl_->assign(value);
}
inline void Response_Bid::set_nurl(const char* value) {
  set_has_nurl();
  if (nurl_ == &::google::protobuf::internal::kEmptyString) {
    nurl_ = new ::std::string;
  }
  nurl_->assign(value);
}
inline void Response_Bid::set_nurl(const char* value, size_t size) {
  set_has_nurl();
  if (nurl_ == &::google::protobuf::internal::kEmptyString) {
    nurl_ = new ::std::string;
  }
  nurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Response_Bid::mutable_nurl() {
  set_has_nurl();
  if (nurl_ == &::google::protobuf::internal::kEmptyString) {
    nurl_ = new ::std::string;
  }
  return nurl_;
}
inline ::std::string* Response_Bid::release_nurl() {
  clear_has_nurl();
  if (nurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nurl_;
    nurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Response_Bid::set_allocated_nurl(::std::string* nurl) {
  if (nurl_ != &::google::protobuf::internal::kEmptyString) {
    delete nurl_;
  }
  if (nurl) {
    set_has_nurl();
    nurl_ = nurl;
  } else {
    clear_has_nurl();
    nurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string adm = 6;
inline bool Response_Bid::has_adm() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Response_Bid::set_has_adm() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Response_Bid::clear_has_adm() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Response_Bid::clear_adm() {
  if (adm_ != &::google::protobuf::internal::kEmptyString) {
    adm_->clear();
  }
  clear_has_adm();
}
inline const ::std::string& Response_Bid::adm() const {
  return *adm_;
}
inline void Response_Bid::set_adm(const ::std::string& value) {
  set_has_adm();
  if (adm_ == &::google::protobuf::internal::kEmptyString) {
    adm_ = new ::std::string;
  }
  adm_->assign(value);
}
inline void Response_Bid::set_adm(const char* value) {
  set_has_adm();
  if (adm_ == &::google::protobuf::internal::kEmptyString) {
    adm_ = new ::std::string;
  }
  adm_->assign(value);
}
inline void Response_Bid::set_adm(const char* value, size_t size) {
  set_has_adm();
  if (adm_ == &::google::protobuf::internal::kEmptyString) {
    adm_ = new ::std::string;
  }
  adm_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Response_Bid::mutable_adm() {
  set_has_adm();
  if (adm_ == &::google::protobuf::internal::kEmptyString) {
    adm_ = new ::std::string;
  }
  return adm_;
}
inline ::std::string* Response_Bid::release_adm() {
  clear_has_adm();
  if (adm_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = adm_;
    adm_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Response_Bid::set_allocated_adm(::std::string* adm) {
  if (adm_ != &::google::protobuf::internal::kEmptyString) {
    delete adm_;
  }
  if (adm) {
    set_has_adm();
    adm_ = adm;
  } else {
    clear_has_adm();
    adm_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ext = 7;
inline bool Response_Bid::has_ext() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Response_Bid::set_has_ext() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Response_Bid::clear_has_ext() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Response_Bid::clear_ext() {
  if (ext_ != &::google::protobuf::internal::kEmptyString) {
    ext_->clear();
  }
  clear_has_ext();
}
inline const ::std::string& Response_Bid::ext() const {
  return *ext_;
}
inline void Response_Bid::set_ext(const ::std::string& value) {
  set_has_ext();
  if (ext_ == &::google::protobuf::internal::kEmptyString) {
    ext_ = new ::std::string;
  }
  ext_->assign(value);
}
inline void Response_Bid::set_ext(const char* value) {
  set_has_ext();
  if (ext_ == &::google::protobuf::internal::kEmptyString) {
    ext_ = new ::std::string;
  }
  ext_->assign(value);
}
inline void Response_Bid::set_ext(const char* value, size_t size) {
  set_has_ext();
  if (ext_ == &::google::protobuf::internal::kEmptyString) {
    ext_ = new ::std::string;
  }
  ext_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Response_Bid::mutable_ext() {
  set_has_ext();
  if (ext_ == &::google::protobuf::internal::kEmptyString) {
    ext_ = new ::std::string;
  }
  return ext_;
}
inline ::std::string* Response_Bid::release_ext() {
  clear_has_ext();
  if (ext_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ext_;
    ext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Response_Bid::set_allocated_ext(::std::string* ext) {
  if (ext_ != &::google::protobuf::internal::kEmptyString) {
    delete ext_;
  }
  if (ext) {
    set_has_ext();
    ext_ = ext;
  } else {
    clear_has_ext();
    ext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string adm_para = 8;
inline bool Response_Bid::has_adm_para() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Response_Bid::set_has_adm_para() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Response_Bid::clear_has_adm_para() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Response_Bid::clear_adm_para() {
  if (adm_para_ != &::google::protobuf::internal::kEmptyString) {
    adm_para_->clear();
  }
  clear_has_adm_para();
}
inline const ::std::string& Response_Bid::adm_para() const {
  return *adm_para_;
}
inline void Response_Bid::set_adm_para(const ::std::string& value) {
  set_has_adm_para();
  if (adm_para_ == &::google::protobuf::internal::kEmptyString) {
    adm_para_ = new ::std::string;
  }
  adm_para_->assign(value);
}
inline void Response_Bid::set_adm_para(const char* value) {
  set_has_adm_para();
  if (adm_para_ == &::google::protobuf::internal::kEmptyString) {
    adm_para_ = new ::std::string;
  }
  adm_para_->assign(value);
}
inline void Response_Bid::set_adm_para(const char* value, size_t size) {
  set_has_adm_para();
  if (adm_para_ == &::google::protobuf::internal::kEmptyString) {
    adm_para_ = new ::std::string;
  }
  adm_para_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Response_Bid::mutable_adm_para() {
  set_has_adm_para();
  if (adm_para_ == &::google::protobuf::internal::kEmptyString) {
    adm_para_ = new ::std::string;
  }
  return adm_para_;
}
inline ::std::string* Response_Bid::release_adm_para() {
  clear_has_adm_para();
  if (adm_para_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = adm_para_;
    adm_para_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Response_Bid::set_allocated_adm_para(::std::string* adm_para) {
  if (adm_para_ != &::google::protobuf::internal::kEmptyString) {
    delete adm_para_;
  }
  if (adm_para) {
    set_has_adm_para();
    adm_para_ = adm_para;
  } else {
    clear_has_adm_para();
    adm_para_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Response_SeatBid

// repeated .TENC.Response.Bid bid = 1;
inline int Response_SeatBid::bid_size() const {
  return bid_.size();
}
inline void Response_SeatBid::clear_bid() {
  bid_.Clear();
}
inline const ::TENC::Response_Bid& Response_SeatBid::bid(int index) const {
  return bid_.Get(index);
}
inline ::TENC::Response_Bid* Response_SeatBid::mutable_bid(int index) {
  return bid_.Mutable(index);
}
inline ::TENC::Response_Bid* Response_SeatBid::add_bid() {
  return bid_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TENC::Response_Bid >&
Response_SeatBid::bid() const {
  return bid_;
}
inline ::google::protobuf::RepeatedPtrField< ::TENC::Response_Bid >*
Response_SeatBid::mutable_bid() {
  return &bid_;
}

// -------------------------------------------------------------------

// Response

// optional string id = 1;
inline bool Response::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Response::id() const {
  return *id_;
}
inline void Response::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Response::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Response::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Response::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* Response::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Response::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string bidid = 2;
inline bool Response::has_bidid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_bidid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_bidid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_bidid() {
  if (bidid_ != &::google::protobuf::internal::kEmptyString) {
    bidid_->clear();
  }
  clear_has_bidid();
}
inline const ::std::string& Response::bidid() const {
  return *bidid_;
}
inline void Response::set_bidid(const ::std::string& value) {
  set_has_bidid();
  if (bidid_ == &::google::protobuf::internal::kEmptyString) {
    bidid_ = new ::std::string;
  }
  bidid_->assign(value);
}
inline void Response::set_bidid(const char* value) {
  set_has_bidid();
  if (bidid_ == &::google::protobuf::internal::kEmptyString) {
    bidid_ = new ::std::string;
  }
  bidid_->assign(value);
}
inline void Response::set_bidid(const char* value, size_t size) {
  set_has_bidid();
  if (bidid_ == &::google::protobuf::internal::kEmptyString) {
    bidid_ = new ::std::string;
  }
  bidid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Response::mutable_bidid() {
  set_has_bidid();
  if (bidid_ == &::google::protobuf::internal::kEmptyString) {
    bidid_ = new ::std::string;
  }
  return bidid_;
}
inline ::std::string* Response::release_bidid() {
  clear_has_bidid();
  if (bidid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bidid_;
    bidid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Response::set_allocated_bidid(::std::string* bidid) {
  if (bidid_ != &::google::protobuf::internal::kEmptyString) {
    delete bidid_;
  }
  if (bidid) {
    set_has_bidid();
    bidid_ = bidid;
  } else {
    clear_has_bidid();
    bidid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .TENC.Response.SeatBid seatbid = 3;
inline int Response::seatbid_size() const {
  return seatbid_.size();
}
inline void Response::clear_seatbid() {
  seatbid_.Clear();
}
inline const ::TENC::Response_SeatBid& Response::seatbid(int index) const {
  return seatbid_.Get(index);
}
inline ::TENC::Response_SeatBid* Response::mutable_seatbid(int index) {
  return seatbid_.Mutable(index);
}
inline ::TENC::Response_SeatBid* Response::add_seatbid() {
  return seatbid_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TENC::Response_SeatBid >&
Response::seatbid() const {
  return seatbid_;
}
inline ::google::protobuf::RepeatedPtrField< ::TENC::Response_SeatBid >*
Response::mutable_seatbid() {
  return &seatbid_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace TENC

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_tenc_2dbidding_2eproto__INCLUDED
